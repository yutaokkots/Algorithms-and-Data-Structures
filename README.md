# **Data Structures & Algorithms**

Algorithms are ordered by [Leetcode's](leetcode.com) problem number. 

## **Introduction**

This repository is a compilation of algorithms, data structures, design patterns, concepts, and visual notes. It serves as a collection of information to help develop structured applications in the future.

## **Languages**

**[Python](./data_structures_and_algorithms/python)**

## **Design Patterns** 

See my <ins>[design pattern repository](https://github.com/yutaokkots/Design-Patterns)</ins>.


**[Design Patterns](./data_structures_and_algorithms/DesignPatterns/design-patterns.md)**

<div align="center">

### <ins>**Design Pattern Categorization**</ins>
|├── Scope ──┤|├─────────|── Purpose ──|─────────┤|
|:---:|---|---|---|
||**Creational**|**Structural**|**Behavioral**|
|**class**|factory|adapter|interpretor<br/> template method|
|**object**|abstract factory<br/> builder<br/> prototype<br/> singleton|adapter<br/> bridge<br/> composite<br/> decorator<br/> facade<br/> flyweight<br/> proxy|chain of responsibility<br/> command<br/> iterator<br/> mediator<br/> memento<br/> observer<br/> state<br/> strategy<br/> visitor|

</div>

## **Data Structures & Algorithms**

|Data Structure | Problem | Notes | 
|-|-|-|
**array / list**| | |
|**[hashtable](./data_structures_and_algorithms/hashtables/hashtables.md)**| | |
|**two-pointer**|||
|**sliding window**|||
**stack**| | |
**queue**| | |
|**[binary heap](./data_structures_and_algorithms/heap/binaryheaps.md)**| | |
**binary search**| | |
|**[tree and binary tree](./data_structures_and_algorithms/trees/trees_notes.md)** <br> **[tree traversal](./data_structures_and_algorithms/trees/tree_traversal.md)**| | |
|**DFS / BFS**|||
|**[graph](./data_structures_and_algorithms/graphs/graphs_notes.md)** | | |
**dynamic programming**| | |


## **Coding Strategies**

<div align="center">

| Principle | Description    |
|----|-----|
|<h3>**SOLID**</h3>|<br> **<u>S</u>ingle Responsibility Principle** - *There should never be more than one reason for a class to change.* <br> **<u>O</u>pen-Closed Principle** - *A module should be open for extension but closed for modification.* <br> **<u>L</u>iskov Substitution Principle** - *Subclasses should be substitutable for their base classes.* <br> **<u>I</u>nterface Segregation Principle** - *Many client specific interfaces are better than one general purpose interface.* <br> **<u>D</u>ependency Inversion Principle** - *Depend upon Abstractions. Do not depend upon concretions.*|
|<h3>**DRY**</h3>| ***Don't Repeat Yourself***|
|<h3>**BUD**</h3> <br> Gayle L. McDowell| ***Bottlenecks*** <br> ***Unnecessary Work*** <br> ***Duplicated Work*** |
|<h3>**REACTO**</h3>| ***Repeat*** (repeat the problem) <br> ***Example*** (provide an example) <br> ***Approach*** (discuss the approach) <br> ***Code*** (code out the problem) <br> ***Test*** (test the code) <br> ***Optimize*** (optimize the solution)|
|<h3>**BCR**</h3>|***Best Conceivable Runtime*** <br> What is the best runtime we can get, and can our current algorithm head towards that? <br> `can we go from O(N^2) -> O(NlogN) -> O(N)`| 
|<h3>**REMSiCo**</h3>|***Readable*** <br> ***Efficient*** <br> ***Maintainable*** <br> ***Simple*** <br> ***Correct***|
|<h3>**BTY**</h3>| ***Better Than Yesterday***|

</div>